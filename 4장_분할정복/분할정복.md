# 분할정복(Divide and Conquer)

 - **목표** : 이 장에서는 분할정복 기법을 더욱 깊이 있게 다룬다. 앞서 다루었던 병합정렬 알고리즘 말고 다른 알고리즘도 다루고 재귀 알고리즘의 수행시간을 표현하는 데 유용한 점화식을 푸는 방법도 소개한다.  
   
   + 분할정복 정의
   
   + 최대부분배열 알고리즘
   
   + 치환법
   
   + 재귀트리방법
   
   + 마스터방법
----

**분할정복기법**  

전체 문제를 원래 문제와 유사하지만 크기가 작은 몇 개의 부분 문제로 분할하고 , 부분 문제를 재귀적으로 푼뒤 그 다음 찾은 해를 결합하여 원래 문제의 해를 찾는 방법론

 - **분할** : 현재의 문제와 동일하되 입력의 크기가 더 작은 다수의 부분 문제로 분할한다.
  
 - **정복** : 부분 문제를 재귀적으로 풀어서 정복한다. 부분 문제의 크기가 충분히 작으면 직접적인 방법으로 푼다.
  
 - **결합** : 부분 문제의 해를 결합해 원래 무제의 해가 되도록 만든다.
 
 ---
 
 **점화식(recurrence)**
 
 점화식은 분할정복 체계와 관련이 많다. 점화식을 통해 분할정복 알고리즘의 수행시간을 자연스럽게 표현할 수 있기 때문이다. 점화식은 더 작은 입력에 대한 자신의 값으로 함수를 나타내는 방정식 또는 부등식이다.
 
 다음은 점화식을 푸는 세 가지 방법이다. 즉 해의 점근적 "Θ" 나 "O" 한계를 얻는 방법을 제시한다.
 
 - **치환법(substitution method)** : 한계를 추측한 후 그 추측식이 옳음을 증명하기 위해 수학적 귀납법을 이용한다.
 
 - **재귀 트리 방법(recursion tree method)** : 점화식을 각 노드가 재귀 호출의 해당 레벨에 따른 비용을 나타내도록 만든 트리로 변환하여 점화식을 푼다. 그리고 이를 위해 합의 한계를 구하는 기법을 이용한다.
 
 - **마스터 방법(master method)** : 다음과 같은 형식으로 된 점화식의 답을 제시해준다. T(n) = aT(n/b) + f(n) 
 
 ----
 
 ## 4.1 최대 부분 배열 문제
 
 연속된 배열 A가 있을 때 부분 배열 중에서 가장 큰 합을 가지는 것을 찾는 문제가 최대 부분 배열 문제이다.
 
 다음의 그림에선 합이 43인 A[8...11]이 최대 부분 배열이다.
 
 ![image](https://user-images.githubusercontent.com/70448161/94344167-50580580-0058-11eb-8452-08cd2fb5b990.png)
 
 주먹구구 식으로 for문을 2번 돌리면 Θ(n²)의 성능이 나오지만 분할정복 기법을 이용해서 재귀적으로 풀면 성능을 더 빠른 알고리즘을 만들 수 있다.
 
 ---
### 분할정복을 이용한 해
 
 먼저 배열을 가능하면 같은 크기의 두 부분 배열로 나누는 것이 좋기 때문에 
 
 배열 A[low ... high] 를  A[low ... mid]  ,  A[mid+1 ... high] 로 나눠주자
 
 이렇게 되면 A[low high]의 모든 연속 부분 배열 A[i...j]는 다음중 하나에 반드시 속한다.
 
   - 부분 배열 A[low ... mid]에 완전히 포함되는 경우
  
   - 부분 배열 A[mid +1 ... high] 에 완전히 포함되는 경우
  
   - 중간값에 걸쳐 있는 경우 
   
   ![최대부분배열그림2](https://user-images.githubusercontent.com/70448161/94344453-7da5b300-005a-11eb-85a8-fae87ec3da47.PNG)
   
   따라서 A[low ... high]의 최대 부분 배열은 반드시 이들 중 하나에 포함된다. A[low ... mid] 와 A[mid+1 ... high]의 최대 부분 배열은 재귀적으로 찾을 수 있다. 
   
   이 두 부분 문제는 최대 부분 배열 중 하나를 찾는 더 작은 문제기 때문이다.
   
   이제 남은 것은 중간값에 걸쳐 있는 최대 부분 배열 중 하나를 찾고 세 부분 배열 중 합이 가장 큰 것을 선택하는 일이다.
   
   먼저 중간값에 걸쳐 있는 최대 부분 배열을 찾는 알고리즘 부터 보자
   
   ![최대부분배열의사코드](https://user-images.githubusercontent.com/70448161/94344599-7cc15100-005b-11eb-8684-921628e9cf56.PNG)
   
     1. 먼저 1-7행은 왼쪽 절반 A[low ... mid]의 최대 부분 배열을 찾는다.
   
     2. sum은 임시 변수로써 배열의 항목들의 합(부분합)을 저장한다.
   
     3. 루프가 진행되면서 5행을 통해 최대부분 배열의 갱신이 진행된다. left sum 보다 큰 부분배열 sum이 나오면 
        left sum 을 갱신시키고 max-left에 그 인덱스를 담아준다.
   
     4. 8-14행은 오른쪽 절반 A[mid+1 ... high]의 최대 부분 배열을 찾는다. 과정은 위와 동일하다.
     
     5. 최대 부분 배열의 경계를 표시하는 인덱스 max-left , max right , 그리고 부분 배열의 합 left-sum + right-sum을 반환해준다.
     
     6. FIND-MAX-CROSSING-SUBARRAY 는 Θ(n)의 시간이 걸린다. 
     
이제 선형 시간이 걸리는 FIND-MAX-CROSSING-SUBARRAY 함수를 가지고 , 최대 부분 배열 문제를 푸는 분할정복 알고리즘에 대한 의사코드를 작성 할 수 있다.

![최대부분배열의사코드2](https://user-images.githubusercontent.com/70448161/94344601-7df27e00-005b-11eb-96f4-6f5bcdccde83.PNG)

    1. 먼저 1행은 베이스케이스에 대한 검사를 진행한다. 단 하나의 원소이면 반환해준다.
   
    2. mid 값을 갱신해주고 재귀호출로 들어간다.
   
    3. 4-5행은 왼쪽과 오른쪽 부분 배열에서 각각 재귀적으로 최대 부분 배열을 찾아서 정복한다.
   
    4. 6-11행은 결합을 담당해준다.
   
    5. 6행은 중간값에 걸쳐 있는 최대 부분 배열을 찾는다.
   
    6. 7-11행은 왼쪽 , 중간 , 오른쪽 중에서 가장 합이 큰 최대부분배열을 반환해준다.
    
--- 

이제 분할정복 알고리즘을 분석해보면 분할정복 알고리즘의 수행시간 점화식은 다음과 같다.

연속된 배열 A를 반으로 나눠서 2개의 작은 문제로 만들었으니 2T(n/2) 이고 FIND-MAX-CROSSING-SUBARRAY 호출은 Θ(n) 시간이 소요되므로 다음과 같다

![점화식](https://user-images.githubusercontent.com/70448161/94344964-dcb8f700-005d-11eb-825d-98767ff68eee.PNG)

지금 얻어낸 점화식은 다음 주제인 점화식 기법에서 여러가지 방법으로 풀어보는 식으로 하겠다.
   
