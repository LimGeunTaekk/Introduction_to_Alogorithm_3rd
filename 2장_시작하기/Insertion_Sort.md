# Insertion Sorting
----

  * 크기가 작은 정렬에 효울적인 **삽입 정렬** 알고리즘으로 시작해보자.
  
  * 삽입 정렬은 카드 놀이를 할 때 손에 쥔 카드를 정렬하는 것과 방법이 같다.
  
  * 왼손은 비었고 카드가 탁자 위에 뒤집힌 채 쌓여 있다고 하자.
  
  * 이제 탁자에서 카드를 한장 씩 가져와 왼손의 적절한 위치에 삽입한다.
  
  * 카드를 삽입할 적절한 위치를 찾기 위해 그림과 같이 왼손에 이미 든 카드와 새 카드를 오른쪽에서 왼쪽 방향으로 차례로 비교하면 된다.
  
  * 결국 왼손에 있는 카드는 항상 정렬되어 있고 , 이는 처음에 탁자에서 맨 위에 쌓였던 카드다.

![2-1](https://user-images.githubusercontent.com/70448161/109410326-04313880-79dd-11eb-921c-e6a6cd3eee19.PNG)

---
 
## 정렬방식

![삽입정렬-그림](https://user-images.githubusercontent.com/70448161/92952941-c6c30800-f49b-11ea-80a0-fa4ad60881a8.PNG)

 * 두번째 원소 부터 시작해서 원래 자리를 찾아가는 정렬 방식
 
 * 항상 key를 기준으로 왼쪽은 정렬이 되어 있는 상태이다
 
----

## 의사코드 및 python Code

![삽입정렬-의사코드](https://user-images.githubusercontent.com/70448161/92952926-c0349080-f49b-11ea-9878-9413450057af.PNG)

* key가 들어갈 곳을 찾을 때 까지 원소들을 한칸씩 뒤로 옮기고 자리를 찾으면 그곳에 key를 삽입

```python
def insertion_sort(arr):
    
    for i in range(1,len(arr)):
        key=arr[i]
        j=i-1
        while j>=0 and key <= arr[j]:
            arr[j+1]=arr[j]
            j=j-1
        arr[j+1]=key
        
    return arr

if __name__ == "__main__":
    arr=[15,78,64,29,34,76,18,39,73]
    print("Before Sorting : {}".format(arr))
    arr=insertion_sort(arr)
    print("After Sorting  : {}".format(arr))

```

----

## 타당성 검사(Loop Invariant)

* 알고리즘의 타당성 검사는 루프 불변성을 이용해서 증명한다. loop invariant는 다음과 같이 정의한다 

* "j에 대해 **A[1...j-1]은 정렬이 되어있어야 한다."**

#### 초기조건 : 루프가 첫 번째 반복을 시작하기 전에 루프 불변성이 참이어야 한다.

* 먼저 루프의 첫 반복이 시작되기, 즉 j = 2일 때 루프 불변성이 성립하는 지를 확인한다. 

* 이때 부분 배열 A[1 ... j-1]은 A[1] 한개의 원소로 구성되는데, 원래는 A[1]의 값이다. 

* 게다가 그 부분 배열은 정렬되어 있으므로 루프의 첫 반복 시작 전에 루프 불변성이 성립한다

#### 유지조건 : 루프의 반복이 시작되기 전에 루프 불변성이 참이었다면 다음 반복이 시작되기 전까지도 계속 참이어야 한다.

* 다음으로 두 번째 특성, 즉 매 반복 시 루프 불변성이 유지되는지를 살펴본다. 

* for 루프의 바디 부분은 A[j]의 올바른 위치를 찾을 때 까지 A[j-1] , A[j-2] , A[j-3] 오른쪽으로 한자리씩 이동시키는 작업을 한다.

* 그러면 배열 A[1..j]는 기존 배열 A[1..j]와 동일한 원소를 정렬한 상태로 갖게 된다. j가 1씩 증가하면서 for루프의 다음 반복에서 루프 불변성이 유지된다.

#### 종료조건 : 루프가 종료될 때 그 불변식이 알고리즘의 타당성을 보이는 데 도움이 될 유용한 특성을 가져야 한다.

* 마지막으로 루프가 종료되었 을 때 어떤 상황이 발생하는지 조사해본다. 

* 삽입 정렬의 경우 for 루프는 j가 A.length = n 보다 커질 때 , 즉 j가 1씩 증가 하므로 j=n+1일때 종료된다. 

* 앞의 루프 불변성의 기술에서 j에 n+1을 넣어 보면 부분 배열 A[1...n]은 원래 A[1...n]의 원소로 구성되지만 정렬된 순서로 저장됨을 알 수 있다. 

* 여기서 A[1...n]은 전체 배열이므로 배열 전체가 정렬 되었으며 이는 알고리즘이 타당함을 의미한다.

----

## 성능분석

![삽입정렬-성능](https://user-images.githubusercontent.com/70448161/92954883-2ec71d80-f49f-11ea-8c9a-9395ef117e08.PNG)

**최악의경우와 최선의 경우를 비교하며 분석해본다.**

#### 최선의 경우

  - 이는 배열이 이미 정렬된 경우다 for문 중간의 while문을 돌리지 않기 때문에 선형의 시간복잡도가 나오게 된다.

  - T(n)= c1n + c2(n-1) + c4(n-1) + c5(n-1) + c8(n-1) >> An+B로 표현할 수 있으며 Θ(n)을 가지게 된다.

#### 최악의 경우

  - 이는 배열이 이미 역순으로 정렬된 경우다. 
  
  - for문 중간의 while문을 돌릴 때 A[j]를 정렬된 부분 A[1...j-1]과 전부 비교해야 하므로 j=2,3,4,...,n에 대해 시그마 안에 있는 Tj = j가 된다. 
  
  - 의사코드 5행과 6행 7행의 시그마 연산을 계산해주면 n^2의 계수가 나오게 되고 결국에는 An^2+bn+c 꼴로 계산된다. 
  
  - 따라서 Θ(n^2)을 가지게 된다



