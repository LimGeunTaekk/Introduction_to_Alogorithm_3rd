# 알고리즘의 역할

---

## 1.1 알고리즘

  * 알고리즘은 간단히 말해 어떤 값이나 값의 집합을 입력으로 받아 또 다른 값이나 값의 집합을 출력하는 잘 정의된 계산 절차를 말한다.
  
  * 따라서 알고리즘은 어떤 입력을 어떤 출력으로 변환하는 일련의 계산 과정이라고 할 수 있다.
  
  * 또한 알고리즘을 잘 정의된 계산 문제를 풀기 위한 도구로도 볼 수 있다.

    - 예를 들어 , 주어진 숫자를 **오름차순**으로 정렬하려 한다고 하자.
    
    - 이는 실제로 자주 발생하는 문제로 , 설계 기법이나 분석 도구를 소개하는 좋은 예로 자주 쓰인다.
    
---
    
  ![1](https://user-images.githubusercontent.com/70448161/109408471-76018600-79cd-11eb-8f82-1893ebb78afa.PNG)
  
  * 그림과 같은 Input이 주어졌다면 , 정렬 알고리즘을 거친 Output은 정렬된 숫자들의 집합으로 나올 것이다.

  * 실제로 많은 프로그램에서 중간 과정으로 사용되는 정렬은 컴퓨터 과학에서 중요한 작업이다. 

  * 알고리즘이 모든 입력 사례에 대해 항상 올바른 출력을 내고 종료할 경우 이를 타당하다(correct)고 하며 , 그 타당한 알고리즘이 주어진 계산 문제를 푼다(slovle)고 말한다.
     
  * 타당하지 않은 알고리즘은 모든 또는 일부 입력 사례에서 종료하지 않거나 잘못된 답을 도출하며 종료 할 것이다.

  * 하지만 상식과 달리 , 타당하지 않은 알고리즘도 오류의 비율을 조절할 수 있으면 유용할 때가 있다.(31장에서 매우 큰 소수를 찾는 알고리즘을 다룰 때 살펴볼 것)
  
---

#### 알고리즘의 특징

  1. 후보해는 많지만 대부분이 문제의 해가 아니다. 문제의 해 혹은 "최상의" 해를 찾는 일은 대단히 도전적인 일이다.

  2. 실용적인 응용 예가 존재한다. 최단 경로 문제가 가장 쉬운 예가 될 수 있다.

      - 트럭이나 기차를 이용하는 운송 회사는 도로망이나 철로망에서 최단 경로를 찾아 노동과 연료 비용을 줄여 경제적 이익을 얻을 수 있다.
      
      - 또한 인터넷에서 라우터가 메세지를 빨리 전달하기 위해 네트워크에서 최단 경로를 찾을 때도 유용하다.
      
      - 뉴욕에서 보스턴까지 운전하려는 사람이 웹사이트나 GPS를 이용해 길을 찾아갈 경우에도 유용하게 사용된다.

  **모든 문제가 알고리즘을 이용해 후보해의 집합을 쉽게 찾을 수 있는 것은 아니다.**
  
    예를 들어 , 신호의 샘플을 표현하는 수치가 있다고 하자.
    
    이 샘플의 이산 푸리에 변환을 계산하려고 한다. 이산 푸리에 변환(DFT)은 샘플 신호에서 주파수 세기가 다양하게 결정되도록 수치적인 계수를 만들면서 시간 영역에서 주파수 영역으로 변환한다.
    
    이산 푸리에 변환은 신호 처리의 핵심일 뿐만 아니라 데이터 압축과 큰 다항 함수 및 정수의 곱셈에도 응용된다.
    
    30장에서는 이 문제를 해결하는 데 효율적인 알고리즘인 고속 푸리에 변환(FFT)을 소개하고 , FFT를 계산하기 위한 하드웨어 회로의 설계도 간단히 설명한다.
    
---    
    
#### 자료구조

  * 이 책은 여러 자료구조도 다룬다.

  * 자료구조는 자료를 편리하게 접근하고 변경하기 위해 자료를 저장하거나 조직하는 방법을 말한다.
 
  * 모든 목적에 가장 맞는 단일 자료구조는 당연히 없다.
  
  * 그러므로 각 자료구조의 장점과 한계를 잘 아는 것이 중요하다.

#### 병렬성

  * 오랫동안 프로세서의 클록 속도가 일정한 비율로 증가하는 것을 기대할 수 있었지만 물리적 한계로 인해 클록 속도를 계속 증가시키기 어려워졌다.
  
  * 클록 속도가 증가하면 전력 밀도도 초 선형적으로 증가해 클록 속도가 충분히 높아지면 컴퓨터 칩이 융해될 위험이 생긴다.
  
  * 그래서 칩은 시간당 계산 성능을 늘리기 위해 단 하나가 아닌 여러 계산을 처리할 수 있도록 코어(core)를 가지도록 설계된다.
  
  * 멀티 코어 컴퓨터는 한 개의 칩 위에 컴퓨터가 여러 대 순차적으로 놓인 것으로 생각할 수 있다.
  
  * 이는 일종의 병렬 컴퓨터(parallel computer)다.
  
  * 멀티 코어 컴퓨터로 부터 최고의 성능을 얻으려면 알고리즘을 설계 할 때 병렬성을 염두에 두어야 한다.
  
---

## 1.2 기술로서의 알고리즘

  * 컴퓨터가 무한히 빠르고 따로 메모리 비용이 들지 않는다고 생각해보자.
  
  * 컴퓨터가 무한히 빠르면 어떤 문제를 해결하는 타당한 알고리즘도 모두 무한히 빠를 것이다.
  
  * 따라서 자신이 구현한 방법이 휼륭한 소프트웨어 공학의 실현 범위에 있음을 보이고 싶겠지만 , 어떤 기법이든 가장 쉽게 구현할 수 있는 것을 자주 사용할 것이다.

  * 하지만 컴퓨터가 상당히 빠를 수는 있지만 , 무한히 빠를 수는 없다. 메모리도 매우 저렴할 수는 있지만 비용이 전혀 들지 않을 수는 없다.

  **결국 계산 시간은 한정된 자원이고 이는 메모리 공간도 마찬가지이다.**
  
  ---
  
#### 효율성
  
  * 동일한 문제를 해결하기 위한 알고리즘이 효율성 면에서 극적으로 다를 수 있다.

  * 그리고 이런 차이는 하드웨어나 소프트웨어로 인한 차이보다 훨씬 더 심각할 수 있다.

  * 잘 설계된 알고리즘은 효율성이 낮은 알고리즘 보다 계산시간적인 차원에서 문제의 크기가 커질수록 그 상대적인 장점도 커지게된다.

---

#### 알고리즘과 다른 기술들

  * 전체 시스템의 성능은 빠른 하드웨어 뿐만 아니라 얼마나 효율적인 알고리즘을 선택하느냥에 따라 서도 결정된다.
  
  * 다른 컴퓨터 기술이 급속하게 발전한 것 처럼 알고리즘 분야에서도 큰 발전이 있었다.

  * 동시대의 다음과 같은 발전된 다른 기술들처럼 컴퓨터 분야에서 알고리즘이 정말 중요할까?(컴퓨터 구조 및 제조기술 , GUI , 객체지향 , 웹 기술 , 네트워킹)

    **대답은 당연히 "그렇다" 이다.**
    
    * 알고리즘에 대한 지식과 기술을 얼마나 알차게 학습했느냐" 가 숙련된 프로그래머와 초보자를 구분하는 기준이 될 수 있다.
    
    * 알고리즘에 대한 별다른 지식 없이도 최신 컴퓨터 기술을 통해 어떤 일을 할 수 있을지도 모른다.
    
    * 하지만 알고리즘에 대한 휼륭한 배경지식을 쌓으면 훨씬 더 많은 일을 할 수 있을 것이다.
